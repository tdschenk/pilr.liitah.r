{
    "contents" : "## FUNCTION: Return complete summary with one row per participant\n#' @export\nfull_summary <- function(pt, filterStart = '2014-04-10T14:00:01Z',\n                         filterEnd = '2016-04-11T23:59:59Z') {\n  basic <- basic_summary(pt, filterStart = filterStart, filterEnd = filterEnd)\n  arrivals <- arrival_table(pt, filterStart = filterStart, filterEnd = filterEnd)\n  arrivals <- subset(arrivals, select = -c(pt))\n  # Difference from manual arrival and trigger\n  trigger_diff <- arrival_diff_avg(pt, filterStart = filterStart, filterEnd = filterEnd)\n  condensed <- arrival_condense(trigger_diff)\n  condensed <- subset(condensed, select = -c(pt))\n  # cbind all dataframes\n  ret <- cbind(basic, arrivals, condensed)\n  ret\n}\n\n## FUNCTION: Quantify arrivals\n## For each at_venue arrival, return if it came from cold, warm, or hot category\n#' @export\narrival_summary <- function(pt, filterStart = '2014-04-10T14:00:01Z',\n                            filterEnd = '2016-04-11T23:59:59Z') {\n  for (k in 1:length(pt)) {\n    log <- read_pilr(data_set = \"pilrhealth:mobile:app_log\", schema = \"1\", \n                     query_params = list(participant = pt[k]))\n    filterStart = filterStart %>% as.POSIXlt(format = \"%Y-%m-%dT%H:%M:%SZ\")\n    filterEnd = filterEnd %>% as.POSIXlt(format = \"%Y-%m-%dT%H:%M:%SZ\")\n    ret <- data.frame(pt = character(), venue = character(), \n                      arrival_time = as.Date(character()),\n                      last_cat = character())\n    if (nrow(log)) {\n      log$local_time = log$local_time %>% as.POSIXlt(format = \"%Y-%m-%dT%H:%M:%SZ\")\n      log = log[log$local_time > filterStart & log$local_time < filterEnd, ]\n      # Only include pollings with a category\n      log <- log[!is.na(log$args.category),]\n      log <- log[log$args.category != \"\",]\n      # Loop through all, find each time you enter 'at_venue'\n      i <- 1\n      polled_at_venue = FALSE\n      while (i <= nrow(log)) {\n        # Find initial instance of at_venue\n        if (log$args.category[i] == \"at_venue\" && !is.na(log$args.category[i])) {\n          # Find time since last reported as hot,warm,cold\n          j <- i - 1\n          while ((is.na(log$args.category[j]) || log$args.category[j] == \"\") && j > 1)\n            j <- j - 1\n          prev_cat <- log$args.category[j]\n          if (j <= 1) prev_cat <- \"first\"\n          temp <- data.frame(pt = pt[k], venue = log$args.nearest_venue[i], \n                             arrival_time = log$local_time[i], \n                             last_cat = prev_cat) \n          ret <- rbind(ret, temp)\n          # Loop through current set of 'at_venue' polls\n          while (log$args.category[i] == \"at_venue\" && i <= nrow(log)\n                 && !is.na(log$args.category[i])) i <- i + 1\n        }\n        i <- i + 1\n      }\n    }\n    else {}\n    if (k == 1) ret2 <- ret\n    else ret2 <- rbind(ret2, ret)\n  }\n  ret2\n}\n\n## FUNCTION: Return percentages of arrival_summary\n#' @export\narrival_table <- function(pt, filterStart = '2014-04-10T14:00:01Z',\n                          filterEnd = '2016-04-11T23:59:59Z') {\n  # For each participant entered summarize arrivals\n  for (i in 1:length(pt)) {\n    arrivals <- arrival_summary(pt[i], filterStart = filterStart, filterEnd = filterEnd)\n    totals <- as.data.frame(table(arrivals$last_cat))\n    from_hot <- as.numeric(totals[totals$Var1 == \"hot\",][2])\n    from_warm <- as.numeric(totals[totals$Var1 == \"warm\",][2])\n    from_cold <- as.numeric(totals[totals$Var1 == \"cold\",][2])\n    if (is.na(from_hot)) from_hot <- 0\n    if (is.na(from_warm)) from_warm <- 0\n    if (is.na(from_cold)) from_cold <- 0\n    temp <- data.frame(pt = pt[i], Hot_Arrivals = from_hot,\n                       Warm_Arrivals = from_warm,\n                       Cold_Arrivals = from_cold)\n    if (i == 1) ret <- temp\n    else ret <- rbind(ret, temp)\n  }\n  ret\n}\n\n## FUNCTION: Basic summary stats\n#' @export\nbasic_summary <- function(pt, filterStart = '2014-04-10T14:00:01Z',\n                          filterEnd = '2016-04-11T23:59:59Z') {\n  for (i in 1:length(pt)) {\n    # Read in data\n    log <- read_pilr(data_set = \"pilrhealth:mobile:app_log\", schema = \"1\", \n                     query_params = list(participant = pt[i]))\n    venues <- read_pilr(data_set = \"pilrhealth:liitah:personal_venue\", schema = \"1\", \n                        query_params = list(participant = pt[i]))\n    filterStart = filterStart %>% as.POSIXlt(format = \"%Y-%m-%dT%H:%M:%SZ\")\n    filterEnd = filterEnd %>% as.POSIXlt(format = \"%Y-%m-%dT%H:%M:%SZ\")\n    if (nrow(log) == 0) {\n      temp <- data.frame(pt = paste0(pt[i], \" (NO LOGIN)\"), \n                         Total_Venues = nrow(venues), \n                         Total_Polls = 0,\n                         Total_Triggers = 0, Polls_at_Venue = 0,\n                         Hot_Polls = 0,\n                         Warm_Polls = 0,\n                         Cold_Polls = 0,\n                         Last_Venue_Added = NA,\n                         Last_Manual_Arrival_Log = NA,\n                         Total_Manual_Arrival_Logs = 0,\n                         Last_Poll = NA,\n                         First_Poll = NA)\n    }\n    else {\n      log$local_time = log$local_time %>% as.POSIXlt(format = \"%Y-%m-%dT%H:%M:%SZ\")\n      log = log[log$local_time > filterStart & log$local_time < filterEnd, ]\n      venues = venues[venues$local_time > filterStart & venues$local_time < filterEnd, ]\n      #training_recs <- read_pilr(data_set = \"pilrhealth:liitah:personal_venue_training_record\", schema = \"1\", \n      #                           query_params = list(participant = pt[i]))\n      filterStart = filterStart %>% as.POSIXlt(format = \"%Y-%m-%dT%H:%M:%SZ\")\n      filterEnd = filterEnd %>% as.POSIXlt(format = \"%Y-%m-%dT%H:%M:%SZ\")\n      log$local_time = log$local_time %>% as.POSIXlt(format = \"%Y-%m-%dT%H:%M:%SZ\")\n      log = log[log$local_time > filterStart & log$local_time < filterEnd, ]\n      if (nrow(venues) != 0) venues$local_time = venues$local_time %>% as.POSIXlt(format = \"%Y-%m-%dT%H:%M:%SZ\")\n      #training_recs$local_time = training_recs$local_time %>% as.POSIXlt(format = \"%Y-%m-%dT%H:%M:%SZ\")\n      #training_recs = training_recs[training_recs$local_time > filterStart & training_recs$local_time < filterEnd, ]\n      # ==== Summarize data ====\n      # Query data for some summary measures\n      polls = log[log$tag == \"POLLING_SERVICE_ANDROID\", ]\n      polls_at_location = polls[polls$args.category == \"at_venue\", ]\n      triggers = log[log$tag == 'ARRIVAL_TRIGGER',]\n      # This line for MANUAL_ARRIVAL\n      training_recs = log[log$tag == 'MANUAL_ARRIVAL',]\n      \n      # Table of the summary measures\n      temp <- data.frame(pt = paste0(pt[i]), \n                         Total_Venues = nrow(venues), \n                         Total_Polls = nrow(polls),\n                         Total_Triggers = nrow(triggers), Polls_at_Venue = nrow(polls_at_location),\n                         Hot_Polls = polls[polls$args.category == \"hot\", ] %>% nrow(),\n                         Warm_Polls = polls[polls$args.category == \"warm\", ] %>% nrow(),\n                         Cold_Polls = polls[polls$args.category == \"cold\", ] %>% nrow(),\n                         Last_Venue_Added = max(venues$local_time) %>% as.character(),\n                         Last_Manual_Arrival_Log = max(training_recs$local_time) %>% as.character(),\n                         Total_Manual_Arrival_Logs = nrow(training_recs),\n                         Last_Poll = max(log$local_time) %>% as.character(),\n                         First_Poll = min(log$local_time) %>% as.character())\n    }\n    if (i == 1) ret <- temp\n    else ret <- rbind(ret, temp)\n  }\n  if (!exists(\"ret\")) ret <- temp\n  ret[ret == -Inf] <- NA\n  ret\n}\n\n## FUNCTION: Comparing locations in venues to training recs\n#' @export\nvenue_diff <- function(pt, filterStart = '2014-04-10T14:00:01Z',\n                       filterEnd = '2016-04-11T23:59:59Z') {\n  # Read in data from PiLR API\n  venues <- read_pilr(data_set = \"pilrhealth:liitah:personal_venue\", schema = \"1\", \n                      query_params = list(participant = pt))\n  training <- read_pilr(data_set = \"pilrhealth:liitah:personal_venue_training_record\", schema = \"1\", \n                        query_params = list(participant = pt))\n  \n  filterStart = filterStart %>% as.POSIXlt(format = \"%Y-%m-%dT%H:%M:%SZ\")\n  filterEnd = filterEnd %>% as.POSIXlt(format = \"%Y-%m-%dT%H:%M:%SZ\")\n  log$local_time = log$local_time %>% as.POSIXlt(format = \"%Y-%m-%dT%H:%M:%SZ\")\n  venues = venues[venues$local_time > filterStart & venues$local_time < filterEnd, ]\n  training = training[training$local_time > filterStart & training$local_time < filterEnd, ]\n  # Format and merge data frame. Keep track of first location entry.\n  venues <- rename(venues, c(\"id\" = \"venue_id\", \"trig_info.lon\" = \"lon\", \"trig_info.lat\" = \"lat\"))\n  training <- rename(training, c(\"info.lon\" = \"lon\", \"info.lat\" = \"lat\"))\n  # Merge venues with training records\n  venues <- subset(venues, select=c(timestamp, pt, venue_id, lon, lat))\n  training <- subset(training, select=c(timestamp, pt, venue_id, lon, lat))\n  # For each venue, find max/min/mean distance from matching training id's\n  ret <- data.frame(venue_id = character(), count = numeric(), \n                    mean = numeric(), min = numeric(), max = numeric())\n  message(\"Distance in meters from original venue\")\n  for (venue in venues$venue_id) {\n    training_sub <- training[training$venue_id == venue,]\n    venues_sub <- venues[venues$venue_id == venue,]\n    message(paste0(\"Venue ID: \", venue))\n    distlist <- numeric()\n    if (nrow(training_sub)) {\n      for (i in 1:nrow(training_sub)) {\n        dist <- distCosine(c(as.numeric(venues_sub$lon[1]), as.numeric(venues_sub$lat[1])), \n                           c(as.numeric(training_sub$lon[i]), as.numeric(training_sub$lat[i])))\n        distlist <- append(distlist, dist)\n        message(dist)\n      }\n      temp <- data.frame(venue_id = venue, count = length(distlist), \n                         mean = mean(distlist), min = min(distlist), max = max(distlist))\n      ret <- rbind(ret, temp)\n    }\n    ret\n  }\n}\n\n## FUNCTION: Time difference between arrival_trigger and manual_arrival\n## Average per venue. Difference in minutes.\n## Positive diff means arrival_trigger came first\n## NA diff means no arrival_trigger detected near manual_arrival\n#' @export\narrival_diff_avg <- function(pt, filterStart = '2014-04-10T14:00:01Z',\n                             filterEnd = '2016-04-11T23:59:59Z') {\n  for (j in 1:length(pt)) {\n    # Read in data\n    log <- read_pilr(data_set = \"pilrhealth:mobile:app_log\", schema = \"1\", \n                     query_params = list(participant = pt[j]))\n    filterStart = filterStart %>% as.POSIXlt(format = \"%Y-%m-%dT%H:%M:%SZ\")\n    filterEnd = filterEnd %>% as.POSIXlt(format = \"%Y-%m-%dT%H:%M:%SZ\")\n    temp <- data.frame(pt = character(), venue = character(),\n                       avg_diff = numeric(), no_triggers = numeric())\n    if (nrow(log)) {\n      log$local_time = log$local_time %>% as.POSIXlt(format = \"%Y-%m-%dT%H:%M:%SZ\")\n      log = log[log$local_time > filterStart & log$local_time < filterEnd, ]\n      occurences <- data.frame(venue = character(), trigger_diff = numeric())\n      # Find each manual_arrival\n      i <- 1\n      while (i < nrow(log)) {\n        if (log$tag[i] == \"MANUAL_ARRIVAL\") {\n          venue <- log$args.response_value[i]\n          # Find time difference of arrival_trigger if present\n          if (i <= 10) sub <- log[1:(i+10),]\n          else if (i >= nrow(log)-10) sub <- log[(i-10):nrow(log),]\n          else sub <- log[(i-10):(i+10),]\n          if (!any(sub$tag == \"ARRIVAL_TRIGGER\")) diff <- NA\n          else {\n            index <- match(\"ARRIVAL_TRIGGER\", sub$tag)\n            diff <- as.numeric(as.POSIXct(log$local_time[i], format = \"%Y-%m-%dT%H:%M:%SZ\") -\n                                 as.POSIXct(sub$local_time[index], format = \"%Y-%m-%dT%H:%M:%SZ\"))\n          }\n          occurences <- rbind(occurences, data.frame(venue = venue, trigger_diff = diff))\n        }\n        i <- i + 1\n      }\n      # Remove any NA venues\n      occurences <- subset(occurences, !is.na(venue))\n      # Summarize by venue\n      i <- 1\n      while (i <= length(unique(occurences$venue))) {\n        sub <- subset(occurences, venue == unique(occurences$venue)[i])\n        num_na <- count(subset(sub, is.na(trigger_diff)))\n        sub <- subset(sub, !is.na(trigger_diff))\n        avg <- mean(sub$trigger_diff, na.rm=TRUE)\n        if (is.nan(avg)) avg = NA\n        temp <- rbind(temp, data.frame(pt = pt[j], venue = unique(occurences$venue)[i], \n                                       avg_diff = avg, no_triggers = as.numeric(num_na)))\n        i <- i + 1\n      }\n      if (nrow(temp) == 0) temp <- data.frame(pt = pt[j], venue = \"NO TRIGGERS\",\n                                              avg_diff = 0, no_triggers = 0)\n    }\n    if (j == 1) ret <- temp\n    else ret <- rbind(ret, temp)\n  }\n  ret\n}\n\n## FUNCTION: Condense arrival_diff results into 1 row per participant for full summary\n#' @export\narrival_condense <- function(diff) {\n  if (nrow(diff)) {\n    for (i in 1:length(unique(diff$pt))) {\n      sub <- subset(diff, pt == unique(diff$pt)[i])\n      avg <- mean(sub$avg_diff, na.rm=TRUE)\n      tot <- sum(sub$no_triggers)\n      temp <- data.frame(pt = unique(diff$pt)[i], Average_Trigger_Diff = avg, No_Triggers = tot)\n      if (i == 1) ret <- temp\n      else ret <- rbind(ret, temp)\n    }\n  }\n  else {\n    ret <- data.frame(pt = NA, Average_Trigger_Diff = NA, No_Triggers = NA)\n  }\n  ret\n}\n\n## FUNCTION: Time difference between arrival_trigger and manual_arrival\n## For every arrival instance. Difference in minutes.\n## Positive diff means arrival_trigger came first\n## NA diff means no arrival_trigger detected near manual_arrival\n#' @export\narrival_diff_inst <- function(pt, filterStart = '2014-04-10T14:00:01Z',\n                              filterEnd = '2016-04-11T23:59:59Z') {\n  for (j in 1:length(pt)) {\n    # Read in data\n    log <- read_pilr(data_set = \"pilrhealth:mobile:app_log\", schema = \"1\", \n                     query_params = list(participant = pt[j]))\n    filterStart = filterStart %>% as.POSIXlt(format = \"%Y-%m-%dT%H:%M:%SZ\")\n    filterEnd = filterEnd %>% as.POSIXlt(format = \"%Y-%m-%dT%H:%M:%SZ\")\n    log$local_time = log$local_time %>% as.POSIXlt(format = \"%Y-%m-%dT%H:%M:%SZ\")\n    log = log[log$local_time > filterStart & log$local_time < filterEnd, ]\n    occurences <- data.frame(pt = character(), local_time = character(),\n                             venue = character(), trigger_diff = numeric())\n    # Find each manual_arrival\n    i <- 1\n    while (i < nrow(log)) {\n      if (log$tag[i] == \"MANUAL_ARRIVAL\") {\n        venue <- log$args.response_value[i]\n        time <- as.POSIXct(log$local_time[i], format = \"%Y-%m-%dT%H:%M:%SZ\")\n        # Find time difference of arrival_trigger if present\n        if (i <= 10) sub <- log[1:(i+10),]\n        else if (i >= nrow(log)-10) sub <- log[(i-10):nrow(log),]\n        else sub <- log[(i-10):(i+10),]\n        if (!any(sub$tag == \"ARRIVAL_TRIGGER\")) diff <- NA\n        else {\n          index <- match(\"ARRIVAL_TRIGGER\", sub$tag)\n          diff <- as.numeric(as.POSIXct(log$local_time[i], format = \"%Y-%m-%dT%H:%M:%SZ\") -\n                               as.POSIXct(sub$local_time[index], format = \"%Y-%m-%dT%H:%M:%SZ\"))\n        }\n        occurences <- rbind(occurences, data.frame(pt = pt[j], local_time = time,\n                                                   venue = venue, trigger_diff = diff))\n      }\n      i <- i + 1\n    }\n    if (j == 1) ret <- occurences\n    else ret <- rbind(ret, occurences)\n  }\n  ret\n}",
    "created" : 1434145583625.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1767569371",
    "id" : "583EC592",
    "lastKnownWriteTime" : 1432763675,
    "path" : "~/GitHub/pilr.liitah.r/R/liitah-data-validation.R",
    "project_path" : "R/liitah-data-validation.R",
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "type" : "r_source"
}